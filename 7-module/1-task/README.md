# Учебный проект: Лента-Меню

Создайте класс `RibbonMenu`, описывающий компонент "Лента-Меню" (для простоты будем называть его "меню").
Данный компонент представляет собой список категорий блюд ресторанного меню.
Фактически мы будем показывать блюда из той категории, которую выбрал пользователь.

В качестве аргумента в конструктор класса передаётся массив категорий для отображения:

```js
let categories = [
  {
    id: '',
    name: 'All'
  },
  {
    id: 'salads', // Уникальный идентификатор категории
    name: 'Salads' // Название категории
  },
  {
    id: 'soups',
    name: 'Soups'
  },
  // и другие...
];

let ribbonMenu = new RibbonMenu(categories);
```

После создания экземпляра класса в `ribbonMenu.elem` должен быть доступен корневой DOM-элемент меню.
На вёрстку компонента можно посмотреть в файле `static.html`, а пример использования — в файле `index.html`.

## Отрисовка вёрстки компонента

Как видно из вёрстки готового меню в файле `static.html`:
- корневой элемент компонента имеет класс `ribbon` 
- ссылки на категории находятся внутри элемента с классом `ribbon__inner`
- вёрстка отдельной ссылки на категорию выглядит так:

```html
<a href="#" class="ribbon__item" data-id="salads">Salads</a>
```

## Прокрутка меню

Как видно из примера, ссылки категорий превышают общую ширину элемента меню.
Чтобы пользователь мог выбрать не отображаемые категории, необходимо прокручивать меню по горизонтали.

Категории меню должны перемещаться влево/вправо при нажатии по кнопкам назад/вперёд.

CSS классы кнопок:
- `ribbon__arrow_right` — класс кнопки переключения на одну категорию "вперёд";
- `ribbon__arrow_left` — класс кнопки переключения на одну категорию "назад";

### Механика прокрутки категорий меню

Структура меню такова, что есть внешний элемент — "контейнер", в котором находится "лента" из нескольких ссылок на категории. 
Внешний элемент имеет фиксированную ширину, поэтому видна только часть ленты.

CSS класс контейнера, в котором находятся все категории — `ribbon__inner`.
Для отображения скрытых ссылок мы будем сдвигать этот элемент на `350px`. Осуществлять это мы будем с помощью встроенного метода `scrollBy`.

Пример:

Чтобы прокрутить ленту меню на `350px` вперёд:
```js
ribbonInner.scrollBy(350, 0); // положительное значение для прокрутки вперёд
```

Чтобы прокрутить ленту меню на `350px` назад:
```js
ribbonInner.scrollBy(-350, 0); // отрицательное значение для прокрутки назад
```

Подробнее про метод `scrollBy` можно прочитать в статье [Размеры и прокрутка окна](https://learn.javascript.ru/size-and-scroll-window#window-scroll)

### Скрываем кнопки переключения при достижении крайних категорий меню

Когда пользователь остановится на последней категории ленты меню, нужно скрыть кнопку переключения вперёд, и наоборот — когда пользователь видит
первую категорию ленты меню, должна быть скрыта кнопка переключения назад. 

Скрывать и показывать кнопки нужно с помощью класса `ribbon__arrow_visible`, если добавить этот класс, то кнопка будет отображаться, в противном случае — она будет скрыта.
Для добавления и удаления класса элемента можно использовать свойство `classList`.

__Важно!__

Прокрутка — это асинхронное действие которое не происходит моментально. 
Выполнение этого действия занимает какое-то время.
Кнопки необходимо скрывать, после окончания прокрутки (в обработчике события `scroll`) на элементе с классом `ribbon__inner`, а не сразу после вызова метода `scrollBy`.

**Как определить текущее положение ленты меню?**

Для этого необходимо вычислить ширину скрытой части меню.
Для части меню, скрытой `слева`, всё очень просто.
Мы можем использовать свойство `scrollLeft` контейнера с категориями (элемент с классом `ribbon__inner`):

```js
let scrollLeft = ribbonInner.scrollLeft;

console.log(scrollLeft); // число пикселей, например, 100 или 0.

```

Другими словами, если значение свойства `scrollLeft` равно `0`, значит мы находимся в самом начале ленты меню (на первой категории), и необходимо скрыть кнопку "назад".
Для части меню, скрытой `справа` всё немного сложнее. 
Чтобы вычислить ширину этой части, нам нужно взять ширину прокрутки меню (свойство `scrollWidth`) и вычесть из неё ширину части меню, скрытой слева(свойство `scrollLeft`) и ширину видимой части меню (свойство `clientWidth`):

```js
let scrollWidth = ribbonInner.scrollWidth; //ширина прокрутки меню
let scrollLeft = ribbonInner.scrollLeft; //ширина части меню, скрытой слева
let clientWidth = ribbonInner.clientWidth; //ширина видимой части меню

let scrollRight = scrollWidth - scrollLeft - clientWidth; // число пикселей, например, 100 или 0.
```

Аналогично, если значение свойства `scrollRight` равно `0`, значит мы находимся в самом конце ленты меню (на последнем слайде), и необходимо скрыть кнопку "вперёд".
В некоторых браузерах значение свойства `scrollRight` может быть представлено десятичной дробью. 
Чтобы обезопасить себя, все значения свойства `scrollRight` от 0 до 1 будем считать равными 0. 
Другими словами, если значение свойства `scrollRight < 1`, то мы можем смело скрыть кнопку "вперёд".

Подробнее про эти свойства и не только можно прочитать в статье [Размеры и прокрутка окна](https://learn.javascript.ru/size-and-scroll-window)

## Выбор конкретной категории

Для выбора конкретной категории блюд пользователю нужно кликнуть по соответствующей ссылке. 
После этого необходимо:
* Прервать действия браузера по умолчанию, вызвав метод `preventDefault` на объекте события.
* Выделить соответствующими стилями, выбранную категорию, добавив ссылке класс `ribbon__item_active`. При этом нужно не забыть удалить этот класс с предыдущей активной категории.
* Дать знать другим компонентам, какую категорию выбрал пользователь. Для этого генерируем пользовательское событие на корневом HTML-элементе компонента (который хранится в свойстве `elem`), следующего вида: 

```js
new CustomEvent('ribbon-select', { // название события должно быть именно 'ribbon-select'
  detail: category.id, // уникальный идентификатор блюда из объекта
  bubbles: true // это событие всплывает (это понадобится в позже)
})
```

Как видите, для генерации такого события необходим уникальный идентификатор категории (`category.id`). 
Для простоты его можно хранить в data-атрибуте, к примеру, мы используем атрибут `data-id` на элементе ссылки.
Про пользовательские события можно прочитать в статье [Генерация пользовательских событий](https://learn.javascript.ru/dispatch-events).
***
__Важно!__

Событие должно **ОБЯЗАТЕЛЬНО** всплывать.
Для этого не забудьте передать свойство `bubbles: true` в опциях в момент создания объекта события, как это показано выше.
Если этого не сделать, событие невозможно будет отловить на элементе `body`, а это потребуется в будущем.
